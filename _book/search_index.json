[
["index.html", "Building API Clients 1 Welcome", " Building API Clients Scott Chamberlain   1 Welcome book for building API clients.  "],
["introduction.html", "2 Introduction 2.1 What you will learn 2.2 Prerequisites 2.3 Acknowledgements 2.4 Colophon", " 2 Introduction xxxx  2.1 What you will learn xxxxx   2.2 Prerequisites To run the code in this book, you will need to install both R and the RStudio IDE, an application that makes R easier to use. Both are open source, free and easy to install:  Download and install R, https://www.r-project.org/alt-home/. Download and install RStudio, http://www.rstudio.com/download. Install needed packages (see below).   2.2.1 R packages pkgs &lt;- c(   &quot;jsonlite&quot;, &quot;knitr&quot;, &quot;httr&quot; ) install.packages(pkgs) You’ll also need to install some R packages. An R package is a collection of functions, data, and documentation that extends the capabilities of base R. Using packages is key to the successful use of R. To install all the packages used in this book open RStudio and run: R will download the packages from CRAN and install them in your system library. If you have problems installing, make sure that you are connected to the internet, and that you haven’t blocked https://cran.rstudio.com in your firewall or proxy. You will not be able to use the functions, objects, and help files in a package until you load it with library(). After you have downloaded the packages, you can load any of the packages into your current R session with the library() command, e.g. library(httr) You will need to reload the package every time you start a new R session.    2.3 Acknowledgements xxx   2.4 Colophon This book was built with: devtools::session_info(pkgs) #&gt; Session info -------------------------------------------------------------- #&gt;  setting  value                                       #&gt;  version  R version 3.2.4 Patched (2016-03-16 r70355) #&gt;  system   x86_64, darwin13.4.0                        #&gt;  ui       X11                                         #&gt;  language (EN)                                        #&gt;  collate  en_US.UTF-8                                 #&gt;  tz       America/Los_Angeles                         #&gt;  date     2016-04-04 #&gt; Packages ------------------------------------------------------------------ #&gt;  package  * version date       source         #&gt;  curl       0.9.6   2016-02-17 CRAN (R 3.2.3) #&gt;  digest     0.6.9   2016-01-08 CRAN (R 3.2.3) #&gt;  evaluate   0.8.3   2016-03-05 CRAN (R 3.2.3) #&gt;  formatR    1.3     2016-03-05 CRAN (R 3.2.3) #&gt;  highr      0.5.1   2015-09-18 CRAN (R 3.2.2) #&gt;  httr       1.1.0   2016-01-28 CRAN (R 3.2.3) #&gt;  jsonlite   0.9.19  2015-11-28 CRAN (R 3.2.2) #&gt;  knitr      1.12.3  2016-01-22 CRAN (R 3.2.3) #&gt;  magrittr   1.5     2014-11-22 CRAN (R 3.2.0) #&gt;  markdown   0.7.7   2015-04-22 CRAN (R 3.2.0) #&gt;  mime       0.4     2015-09-03 CRAN (R 3.2.0) #&gt;  openssl    0.9.2   2016-02-26 CRAN (R 3.2.3) #&gt;  R6         2.1.2   2016-01-26 CRAN (R 3.2.3) #&gt;  stringi    1.0-1   2015-10-22 CRAN (R 3.2.2) #&gt;  stringr    1.0.0   2015-04-30 CRAN (R 3.2.0) #&gt;  yaml       2.1.13  2014-06-12 CRAN (R 3.2.0)   "],
["data-types.html", "3 Data Types", " 3 Data Types xxxx  "],
["apis.html", "4 APIs 4.1 Breakdown of the types 4.2 REST APIs 4.3 HTTP", " 4 APIs  4.1 Breakdown of the types  SOAP REST RPC    4.2 REST APIs   4.3 HTTP   "],
["working-with-apis.html", "5 Working with APIs 5.1 xxx", " 5 Working with APIs  5.1 xxx   "],
["api-clients.html", "6 API clients 6.1 xxx", " 6 API clients  6.1 xxx   "],
["curl.html", "7 curl 7.1 Discover curl options 7.2 Other ways to use curl besides R 7.3 Install httr 7.4 general option setting 7.5 curl options in rOpenSci packages 7.6 timeout 7.7 verbose 7.8 headers 7.9 authenticate 7.10 cookies 7.11 progress 7.12 proxies 7.13 user agent", " 7 curl curl is the de facto standard tool for making HTTP requests - in addition to many other types of data requests. It is also an R package (https://cran.rstudio.com/web/packages/curl/).  7.1 Discover curl options You can go to the source, that is the curl manual page at http://curl.haxx.se/docs/manpage.html. In R: RCurl::listCurlOptions() for finding curl options, give website for more info and equivalent call in httr is httr::httr_options(). httr::httr_options() gives more information for each curl option, including the libcurl variable name (e.g., CURLOPT_CERTINFO) and the type of variable (e.g., logical).   7.2 Other ways to use curl besides R Perhaps the canonical way to use curl is on the command line. You can get curl for your operating system at http://curl.haxx.se/download.html, though hopefully you already have curl. Once you have curl, you can have lots of fun. For example, get the contents of the Google landing page: curl https://www.google.com  If you like that you may also like httpie, a Python command line tool that is a little more convenient than curl (e.g., JSON output is automatically parsed and colorized). Alot of data from the web is in JSON format. A great command line tool to pair with curl is jq.   Note: if you are on windows you may require extra setup if you want to play with curl on the command line. OSX and linux have it by default. On Windows 8, installing the latest version from here http://curl.haxx.se/download.html#Win64 worked for me.    7.3 Install httr  Note: RCurl is a dependency, so you’ll get it when you install httr  install.packages(&quot;httr&quot;) There are some new features in httr dev version you may want. If so, do: install.packages(&quot;devtools&quot;) devtools::install_github(&quot;hadley/httr&quot;) Load httr library(&quot;httr&quot;)   7.4 general option setting With httr you can either set globally for an R session like set_config(timeout(seconds = 2)) Or use with_config() with_config(verbose(), {   GET(&quot;http://www.google.com/search&quot;) }) Or extensions to with_*, like for verbose output with_verbose(   GET(&quot;http://www.google.com/search&quot;) ) #&gt; Response [http://www.google.com/webhp] #&gt;   Date: 2016-04-15 13:53 #&gt;   Status: 200 #&gt;   Content-Type: text/html; charset=ISO-8859-1 #&gt;   Size: 10.5 kB #&gt; &lt;!doctype html&gt;&lt;html itemscope=&quot;&quot; itemtype=&quot;http://schema.org/WebPage&quot; l... #&gt; function _gjh(){!_gjuc()&amp;&amp;window.google&amp;&amp;google.x&amp;&amp;google.x({id:&quot;GJH&quot;},f... #&gt; &lt;/style&gt;&lt;style&gt;body,td,a,p,.h{font-family:arial,sans-serif}body{margin:0... #&gt; if (!iesg){document.f&amp;&amp;document.f.q.focus();document.gbqf&amp;&amp;document.gbqf... #&gt; } #&gt; })();&lt;/script&gt;&lt;div id=&quot;mngb&quot;&gt;    &lt;div id=gbar&gt;&lt;nobr&gt;&lt;b class=gb1&gt;Search&lt;... Or pass into each function call GET(&quot;http://www.google.com/search&quot;, query=list(q=&quot;httr&quot;), timeout(seconds = 0.5)) With RCurl you can set options for a function call by passing curl options to the .opts parameter getForm(&quot;http://www.google.com/search?q=RCurl&quot;, btnG=&quot;Search&quot;, .opts = list(timeout.ms = 20)) For all examples below I’ll use httr, and pass in config options to function calls.   7.5 curl options in rOpenSci packages In most of our packages we allow you to pass in any curl options, either via ... or a named parameter. We are increasingly making our packages consistent, but they may not all have this ability yet. For example, using the rgbif package, an R client for GBIF: install.packages(&quot;rgbif&quot;) verbose output library(&quot;rgbif&quot;) res &lt;- occ_search(geometry=c(-125.0,38.4,-121.8,40.9), limit=20, config=verbose()) #&gt; -&gt; GET /v1/occurrence/search?geometry=POLYGON%28%28-125%2038.4%2C%20-121.8%2038.4%2C%20-121.8%2040.9%2C%20-125%2040.9%2C%20-125%2038.4%29%29&amp;limit=20&amp;offset=0 HTTP/1.1 #&gt; -&gt; User-Agent: curl/7.37.1 Rcurl/1.95.4.5 httr/0.6.0 #&gt; -&gt; Host: api.gbif.org #&gt; -&gt; Accept-Encoding: gzip #&gt; -&gt; Accept: application/json, text/xml, application/xml, */* #&gt; -&gt; #&gt; &lt;- HTTP/1.1 200 OK #&gt; &lt;- Content-Type: application/json #&gt; &lt;- Access-Control-Allow-Origin: * #&gt; &lt;- Server: Jetty(9.1.z-SNAPSHOT) #&gt; &lt;- x-api-url: /v1/occurrence/search?geometry=POLYGON%28%28-125%2038.4%2C%20-121.8%2038.4%2C%20-121.8%2040.9%2C%20-125%2040.9%2C%20-125%2038.4%29%29&amp;limit=20&amp;offset=0 #&gt; &lt;- Content-Length: 48698 #&gt; &lt;- Accept-Ranges: bytes #&gt; &lt;- Date: Tue, 16 Dec 2014 23:35:52 GMT #&gt; &lt;- X-Varnish: 1067986052 1067940827 #&gt; &lt;- Age: 209 #&gt; &lt;- Via: 1.1 varnish #&gt; &lt;- Connection: keep-alive #&gt; &lt;- Print progress res &lt;- occ_search(geometry=c(-125.0,38.4,-121.8,40.9), limit=20, config=progress()) #&gt; |===================================================================| 100% You can also combine curl options - use c() in this case to combine them c(verbose(), progress()) #&gt; &lt;request&gt; #&gt; Options: #&gt; * debugfunction: function (type, msg)  #&gt; { #&gt;     switch(type + 1, text = if (info) prefix_message(&quot;*  &quot;, msg), headerIn = prefix_message(&quot;&lt;- &quot;, msg), headerOut = prefix_message(&quot;-&gt; &quot;, msg), dataIn = if (data_in) prefix_message(&quot;&lt;&lt;  &quot;, msg, TRUE), dataOut = if (data_out) prefix_message(&quot;&gt;&gt; &quot;, msg, TRUE), sslDataIn = if (data_in &amp;&amp; ssl) prefix_message(&quot;*&lt; &quot;, msg, TRUE), sslDataOut = if (data_out &amp;&amp; ssl) prefix_message(&quot;*&gt; &quot;, msg, TRUE)) #&gt; } #&gt; * verbose: TRUE #&gt; * noprogress: FALSE #&gt; * progressfunction: function (down, up)  #&gt; { #&gt;     if (type == &quot;down&quot;) { #&gt;         total &lt;- down[[1]] #&gt;         now &lt;- down[[2]] #&gt;     } #&gt;     else { #&gt;         total &lt;- up[[1]] #&gt;         now &lt;- up[[2]] #&gt;     } #&gt;     if (total == 0 &amp;&amp; now == 0) { #&gt;         bar &lt;&lt;- NULL #&gt;         first &lt;&lt;- TRUE #&gt;         return(TRUE) #&gt;     } #&gt;     if (total == 0) { #&gt;         if (first) { #&gt;             first &lt;&lt;- FALSE #&gt;         } #&gt;         cat(&quot;\\rDownloading: &quot;, bytes(now, digits = 2), &quot;     &quot;, sep = &quot;&quot;) #&gt;         if (now == total)  #&gt;             cat(&quot;\\n&quot;) #&gt;         utils::flush.console() #&gt;     } #&gt;     else { #&gt;         if (is.null(bar)) { #&gt;             bar &lt;&lt;- utils::txtProgressBar(max = total, style = 3) #&gt;         } #&gt;         utils::setTxtProgressBar(bar, now) #&gt;     } #&gt;     TRUE #&gt; } res &lt;- occ_search(geometry=c(-125.0,38.4,-121.8,40.9), limit=20, config=c(verbose(), progress())) #&gt; -&gt; GET /v1/occurrence/search?geometry=POLYGON%28%28-125%2038.4%2C%20-121.8%2038.4%2C%20-121.8%2040.9%2C%20-125%2040.9%2C%20-125%2038.4%29%29&amp;limit=20&amp;offset=0 HTTP/1.1 #&gt; -&gt; User-Agent: curl/7.37.1 Rcurl/1.95.4.5 httr/0.6.0 #&gt; -&gt; Host: api.gbif.org #&gt; -&gt; Accept-Encoding: gzip #&gt; -&gt; Accept: application/json, text/xml, application/xml, */* #&gt; -&gt; #&gt; &lt;- HTTP/1.1 200 OK #&gt; &lt;- Content-Type: application/json #&gt; &lt;- Access-Control-Allow-Origin: * #&gt; &lt;- Server: Jetty(9.1.z-SNAPSHOT) #&gt; &lt;- x-api-url: /v1/occurrence/search?geometry=POLYGON%28%28-125%2038.4%2C%20-121.8%2038.4%2C%20-121.8%2040.9%2C%20-125%2040.9%2C%20-125%2038.4%29%29&amp;limit=20&amp;offset=0 #&gt; &lt;- Content-Length: 48698 #&gt; &lt;- Accept-Ranges: bytes #&gt; &lt;- Date: Tue, 16 Dec 2014 23:35:52 GMT #&gt; &lt;- X-Varnish: 1067986052 1067940827 #&gt; &lt;- Age: 209 #&gt; &lt;- Via: 1.1 varnish #&gt; &lt;- Connection: keep-alive #&gt; &lt;- #&gt;   |======================================================================| 100%   7.6 timeout  Set a timeout for a request. If request exceeds timeout, request stops.   httr: timeout(seconds=2) Here, the value is in seconds - converted to ms internally RCurl: timeout.ms=2000 Here, the value is in ms   Note: For this section and those following, I’ll mention an RCurl equivalent if there is one.  GET(&quot;http://www.google.com/search&quot;, timeout(0.01)) #&gt; Error in function (type, msg, asError = TRUE)  : #&gt;   Connection timed out after 16 milliseconds  Why use this? You sometimes are working with a web resource that is somewhat unreliable. For example, if you want to run a script on a server that may take many hours, and the web resource could be down at some point during that time, you could set the timeout and error catch the response so that the script doesn’t hang on a server that’s not responding. Another example could be if you call a web resource in an R package. In your test suite, you may want to test that a web resource is responding quickly, so you could set a timeout, and not test if that fails.    7.7 verbose  Print detailed info on a curl call   httr: verbose() RCurl: verbose=TRUE  Just do a HEAD request so we don’t have to deal with big output HEAD(&quot;http://www.google.com/search&quot;, verbose()) #&gt; -&gt; HEAD / HTTP/1.1 #&gt; -&gt; User-Agent: curl/7.37.1 Rcurl/1.95.4.5 httr/0.6.0 #&gt; -&gt; Host: had.co.nz #&gt; -&gt; Accept-Encoding: gzip #&gt; -&gt; Accept: application/json, text/xml, application/xml, */* #&gt; -&gt; #&gt; &lt;- HTTP/1.1 200 OK #&gt; &lt;- X-Powered-By: PHP/4.4.6 #&gt; &lt;- Content-type: text/html #&gt; &lt;- Date: Tue, 16 Dec 2014 21:03:21 GMT #&gt; &lt;- Server: LiteSpeed #&gt; &lt;- Connection: Keep-Alive #&gt; &lt;- Keep-Alive: timeout=5, max=100 #&gt; &lt;- #&gt; Response [http://had.co.nz/] #&gt;   Date: 2014-12-16 12:29 #&gt;   Status: 200 #&gt;   Content-Type: text/html #&gt; &lt;EMPTY BODY&gt;  Why use this? As you can see verbose output gives you lots of information that may be useful for debugging a request. You typically don’t need verbose output unless you want to inspect a request.    7.8 headers  Add headers to modify requests, including authentication, setting content-type, accept type, etc.   httr: add_headers() RCurl: httpheader  res &lt;- HEAD(&quot;http://www.google.com/search&quot;, add_headers(Accept = &quot;application/json&quot;)) res$request$opts$httpheader #&gt; NULL  Note: there are shortcuts for add_headers(Accept = &quot;application/json&quot;) and add_headers(Accept = “application/xml”): accept_json(), and accept_xml()   Why use this? For some web resources, using headers is mandatory, and httr makes including them quite easy. Headers are nice too because e.g., passing authentication in the header instead of the URL string means your private data is not as exposed to prying eyes.    7.9 authenticate  Set authentication details for a resource   httr: authenticate(), oauth2.0_token(), oauth_app(), oauth_endpoint(), etc. RCurl: various  authenticate() for basic username/password authentication authenticate(user = &quot;foo&quot;, password = &quot;bar&quot;) #&gt; &lt;request&gt; #&gt; Options: #&gt; * httpauth: 1 #&gt; * userpwd: foo:bar To use an API key, this depends on the data provider. They may request it one or either of the header (in multiple different ways) HEAD(&quot;http://www.google.com/search&quot;, add_headers(Authorization = &quot;Bearer 234kqhrlj2342&quot;)) # or HEAD(&quot;http://www.google.com/search&quot;, add_headers(&quot;token&quot; = &quot;234kqhrlj2342&quot;)) or as a query parameter (which is passed in the URL string) HEAD(&quot;http://www.google.com/search&quot;, query = list(api_key = &quot;&lt;your key&gt;&quot;)) Another authentication options is OAuth workflows. OAuth2 is probably more commonly used than OAuth1.  Find OAuth settings for github http://developer.github.com/v3/oauth/  endpts &lt;- oauth_endpoint(authorize = &quot;authorize&quot;, access = &quot;access_token&quot;, base_url = &quot;https://github.com/login/oauth&quot;)  Register an application at https://github.com/settings/applications. Use any URL you would like for the homepage URL (http://github.com is fine) and http://localhost:1410 as the callback url. Insert your client ID and secret below - if secret is omitted, it will look it up in the GITHUB_CONSUMER_SECRET environmental variable.  myapp &lt;- oauth_app(appname = &quot;github&quot;, key = &quot;&lt;key&gt;&quot;, secret = &quot;&lt;secret&gt;&quot;)  Get OAuth credentials  github_token &lt;- oauth2.0_token(endpts, myapp)  Use API  gtoken &lt;- config(token = github_token) req &lt;- GET(&quot;https://api.github.com/rate_limit&quot;, gtoken) content(req)   7.10 cookies  Set or get cookies.   httr: set_cookies(), cookies() RCurl: cookie  Set cookies GET(&quot;http://httpbin.org/cookies&quot;, set_cookies(a = 1, b = 2)) #&gt; Response [http://httpbin.org/cookies] #&gt;   Date: 2016-04-15 13:53 #&gt;   Status: 200 #&gt;   Content-Type: application/json #&gt;   Size: 51 B #&gt; No encoding supplied: defaulting to UTF-8. #&gt; { #&gt;   &quot;cookies&quot;: { #&gt;     &quot;a&quot;: &quot;1&quot;,  #&gt;     &quot;b&quot;: &quot;2&quot; #&gt;   } #&gt; } If there are cookies in a response, you can access them easily with cookies() res &lt;- GET(&quot;http://httpbin.org/cookies/set&quot;, query = list(a = 1, b = 2)) cookies(res) #&gt;        domain  flag path secure expiration name value #&gt; 1 httpbin.org FALSE    /  FALSE       &lt;NA&gt;    a     1 #&gt; 2 httpbin.org FALSE    /  FALSE       &lt;NA&gt;    b     2   7.11 progress  Print curl progress   httr: progress() RCurl: progressfunction  res &lt;- GET(&quot;http://httpbin.org&quot;, progress()) #&gt; |==================================| 100%  Why use this? As you could imagine, this is increasingly useful as a request for a web resource takes longer and longer. For very long requests, this will help you know approximately when a request will finish.    7.12 proxies  When behind a proxy, give authentiction details for your proxy.   httr: use_proxy() RCurl: See various curl options that start with proxy  GET(&quot;http://www.google.com/search&quot;, use_proxy(url = &quot;125.39.66.66&quot;, port = 80, username = &quot;username&quot;, password = &quot;password&quot;))  Why use this? Most of us likely don’t need to worry about this. However, if you are in a work place, or maybe in certain geographic locations, you may have to use a proxy. I haven’t personally used a proxy in R, so any feedback on this is great.    7.13 user agent  Some resources require a user-agent string.   httr: user_agent() RCurl: useragent  Get the default user agent set if using httr GET(&quot;http://httpbin.org/user-agent&quot;) #&gt; Response [http://httpbin.org/user-agent] #&gt;   Date: 2016-04-15 13:53 #&gt;   Status: 200 #&gt;   Content-Type: application/json #&gt;   Size: 61 B #&gt; No encoding supplied: defaulting to UTF-8. #&gt; { #&gt;   &quot;user-agent&quot;: &quot;libcurl/7.43.0 r-curl/0.9.7 httr/1.1.0&quot; #&gt; } Set a user agent string GET(&quot;http://httpbin.org/user-agent&quot;, user_agent(&quot;its me!&quot;)) #&gt; Response [http://httpbin.org/user-agent] #&gt;   Date: 2016-04-15 13:53 #&gt;   Status: 200 #&gt;   Content-Type: application/json #&gt;   Size: 30 B #&gt; No encoding supplied: defaulting to UTF-8. #&gt; { #&gt;   &quot;user-agent&quot;: &quot;its me!&quot; #&gt; }  Why use this? This is set by default in a http request, as you can see in the first example above for user agent. Some web APIs require that you set a specific user agent. For example, the GitHub API requires that you include a user agent string in the header of each request that is your username or the name of your application so they can contact you if there is a problem.    "],
["ftp.html", "8 FTP", " 8 FTP xxxx  "],
["http-1.html", "9 HTTP", " 9 HTTP xxxx  "],
["caching.html", "10 Caching 10.1 Why cache? 10.2 http based caching 10.3 R based caching", " 10 Caching  10.1 Why cache?   10.2 http based caching  e-tag cache control    10.3 R based caching  10.3.1 vcr    "],
["packaging.html", "11 Packaging", " 11 Packaging xxxx  "],
["testing.html", "12 Testing 12.1 testthat 12.2 vcr", " 12 Testing  12.1 testthat   12.2 vcr    "]
]
